## These two functions, work in tandem to cache the inverse of a
## matrix. The first, makeCacheMatrix, accepts a matrix as an
## argument, then generates a list of four functions intended to
## be used as an argument for the second function, cacheSolve.
## The cacheSolve function, when passed a list generated by
## makeCacheMatrix, will do one of two things based on whether or
## not the matrix argument of makeCacheMatrix has been changed 
## since the last time that cacheSolve was run. If the matrix has
## been changed (either by running makeCacheMatrix on another
## matrix or by passing a new matrix to
## makeCacheMatrix.object$set()), then it will calculate and
## print the inverse of the matrix. If instead the matrix has not 
## been changed since cacheSolve was last run, then cacheSolve 
## will look up and print the cached inverse matrix without having
## to rerun the calculation.

## makeCacheMatrix takes a matrix as an argument and generates a
## list containing four functions that are integral to the
## operation of cacheSolve. When makeCacheMatrix is called, it
## starts by initializing two objects, x and m. x is the matrix 
## that is passed to makeCacheMatrix as an argument, while m is
## initialized to NULL. The first function, set, allows a matrix
## to be set as the desired matrix whose inverse is to be found.
## As with makeCacheMatrix, set defines x as the matrix to be
## inverted and defines m as NULL. Critically, the <<- operator
## is used, so x and m are changed not only in the 
## makeCacheMatrix$set environment, but also in the 
## makeCacheMatrix environment, thereby updating the values of
## x and m used by the remaining three functions. The second
## function, get, accepts no argument and outputs x, the matrix
## to be inverted. The third function, setinv, sets the value
## of m to the argument it is passed. The fourth function,
## getinv, outputs the value of m. Finally, all four functions
## are organized into a list object. This list can be passed
## to cacheSolve to invert the matrix originally passed to
## makeCacheMatrix.


makeCacheMatrix <- function(x = matrix()) {
  m <- NULL
  set <- function(y) {
    x <<- y
    m <<- NULL
  }
  get <- function() x
  setinv <- function(inverse) m <<- inverse
  getinv <- function() m
  list(set = set, get = get,
       setinv = setinv,
       getinv = getinv)
}

## When cacheSolve is called using the list of functions defined
## in makeCacheMatrix, it first defines a new object, m, using
## the getinv function defined in makeCacheMatrix. Because the
## getinv function simply outputs the value of m (as defined in
## the makeCacheMatrix environment), the value of m in cacheSolve
## is therefore set the the value of m last defined in 
## makeCacheMatrix. The function will then have one of two
## different behaviors based on whether or not m is NULL. Note
## that because m is set to NULL whenever makeCacheMatrix is
## called (or the matrix is changed by calling 
## makeCacheMatrix.object$set()), the behavior of cacheSolve is
## effectively determined by whether or not the matrix to be
## inverted has been updated since cacheSolve was last called.

## If the matrix has been updated, then m will be NULL and
## cacheSolve will define an object named data based on
## makeCacheMatrix$get(), which itself outputs
## makeCacheMatrix$x, or the matrix to be inverted.
## cacheSolve will then run the calculation to invert the
## matrix using the solve function, set its own m object as well
## as the m object in makeCacheMatrix equal to this inverted 
## matrix, then print the inverted matrix.

## If the matrix has not been updated since cacheSolve was last
## called, the value of m will not be NULL. The value of m will  
## instead be set to the inverted matrix. In this case,
## cacheSolve will simply return the value of m. In either case
## the ultimate outcome of cacheSolve is to output the inverse
## of the matrix used as the argument of MakeCacheMatrix, but
## cacheSolve is set up in such a way that it can skip the
## calculation of the inverse matrix if that action has already
## been performed.

cacheSolve <- function(x, ...) {
  m <- x$getinv()
  if(!is.null(m)) {
    message("getting cached data")
    return(m)
  }
  data <- x$get()
  m <- solve(data, ...)
  x$setinv(m)
  m
}
